---
title: "Databases & R - Read & Write to a Database from R"
author: Aravind Hebbali
twitterImg: /img/dbi_cover_image.png
description: "Learn to connect, explore and query database from R"
date: '2019-08-02'
slug: read-write-database-r
categories:
  - databases
tags:
  - dbi
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r rfm_cover_image, echo=FALSE, fig.align="center", out.width="100%"}
knitr::include_graphics("/img/dbi_cover_image.png")
```

## Introduction

In this tutorial, we will learn to read & write data to a database from R.

## Resources

Below are the links to all the resources related to this post:

- <a href="https://slides.rsquaredacademy.com/sql/sqlite.html#/section" target="_blank">Slides</a>
- <a href="https://github.com/rsquaredacademy-education/online-courses/" target="_blank">Code & Data</a>
- <a href="https://rstudio.cloud/project/430439" target="_blank">RStudio Cloud</a>

You can try our **free online course** [**Working with Databases using R**](https://rsquared-academy.thinkific.com/courses/working-with-databases-using-r) if you prefer to learn through self paced online courses.

```{r dbi_youtube_demo, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "bPlGPmjPFeU")
```

## Libraries

Before we connect to and explore the local SQLite database, let us take a look at the R packages we will use in this post. 

- [DBI](http://r-dbi.github.io/DBI/) a database interface for R 
- [RSQLite](https://rsqlite.r-dbi.org/) driver for SQLite

```{r load_libs, message=FALSE, warning=FALSE}
# install.packages(c("DBI", "dbplyr", "dplyr", "dbplot", "ggplot2", "modeldb",
# "tidypredict", "config"))
library(DBI)
library(dbplyr)
library(dplyr)
library(dbplot)
library(ggplot2)
library(modeldb)
library(tidypredict)
library(config)
```

If you do not have all the above packages installed, go ahead and install them. In the R script we are sharing with you, we have commented out the code for installing the packages. If you are using the RStudio Cloud project, we have already installed the packages in the project and you can just load them into the R session using `library()`. 

As and when we come to the specific sections where we are using these packages, they will be reintroduced and we will look at their documentation and explore the functions we will use.

## Querying Data

Now that we have successfully connected to the database and explored the tables, let us look at querying data from the `ecom` table. In this section,
we will learn to:

- read entire table
- read few rows
- read data in batches

#### Entire Table

We can read an entire table from a database using `dbReadTable()` provided the table is not very large. We will read data from the `COMPANY` table as it has few rows and will not fill the whole page. The first input is the database connection name and the second input is the name of the table in quotes.

```{r dbi_connect, include=FALSE}
con <- DBI::dbConnect(RSQLite::SQLite(), dbname = "mydatabase.db")
con
```

```{r query_entire_table}
DBI::dbReadTable(con, 'COMPANY')
```

In some cases, we may not need the entire table but only a specific number of rows. Use `dbGetQuery()` and supply a SQL statement specifying the number of rows of data to be read from the table. In the below example, we read ten rows of data from the `ecom` table.

#### Few Rows

```{r query_few_rows}
DBI::dbGetQuery(con, "select * from ecom limit 10")
```

In case of very large table, we can read data in batches using `dbSendQuery()` and `dbFetch()`. We can mention the number of rows of data to be read while fetching the data using the query generated by `dbSendQuery()`.

#### Read Data in Batches

```{r query_data_in_batches}
query  <- DBI::dbSendQuery(con, 'select * from ecom')

# first batch of 10 rows
DBI::dbFetch(query, n = 10)

# second batch of 10 rows
DBI::dbFetch(query, n = 10)
```

### Your Turn

- list fields in the `trade` table
- read all rows & columns from the `trade` table
- read first 30 rows from the `trade` table

## Query

In this section, we will look at a bunch of functions that will allow us to get information about the query we sent to the database in the previous section to fetch data in batches. Before we start, let us look at the output from `query`.

```{r query_print}
query
```

We can see the follwing:

- SQL statement 
- number of rows fetched (15) 
- status of the query (incomplete) 
- and number of rows changed in the table (0)

The status is incomplete as we are querying data in batches and the number of rows changed is `0` since ran a `SELECT` SQL statement which does not modify the table.

#### Query Status

To know the status of a query, use `dbHasCompleted()`. It is very useful in
cases of queries that might take a long time to complete. It will return a logical value i.e. `TRUE` or `FALSE`. In our example, since we are querying data in batches, the output will be `FALSE`. 

```{r query_status}
DBI::dbHasCompleted(query)
```

#### Query Info

`dbGetInfo()` will display the following:

- SQL statement being executed
- the count of rows fetched/affected
- and the status of the query

```{r query_info}
DBI::dbGetInfo(query)
```

The output is similar to what we saw when we printed `query`.

#### Latest Query

To view the query used in `dbSendQuery()` or `dbSendStatement()`, use `dbGetStatement()`.

```{r get_latest_query}
DBI::dbGetStatement(query)
```

#### Rows Fetched

`dbGetRowCount()` will return the total number of rows actually fetched from the table in the database. 

```{r rows_fetched}
DBI::dbGetRowCount(query)
```

#### Rows Affected

The total number of rows added, deleted or updated by a data manipulation statement is returned by `dbGetRowsAffected()`. In our example, the SQL statemet did not modify the table in any way and hence the output will be `0`.

```{r rows_affected}
DBI::dbGetRowsAffected(query)
```

#### Column Info

`dbColumnInfo()` returns a `data.frame` that describes the output of a query. In the below example, it returns the column name and data type of the output from the query.

```{r column_info}
DBI::dbColumnInfo(query)
```

#### Clear Results

To free all resources associated with a result set, use `dbClearResult()`. After running the below code, we will not be able to retrieve any information about `query` i.e. try running `dbGetInfo(query)` or `dbGetStatement(query)` and R will return an error.

```{r clear_query_result}
DBI::dbClearResult(query)
```

## Tables

In this section, we will learn to:

- check if a table exists
- create table
- overwrite table
- append data to a table
- insert rows into a table
- append one table to another
- remove a table

#### Check Table Name

It is a good practice to check whether a table of the same name exists before trying to create a new one in the database. In the below example, we use `dbExistsTable()` to check if the database already has a table by the name `trial_db`. `dbExistsTable()` always returns a logical value.

```{r dblisttable}
DBI::dbExistsTable(con, "trial_db")
```

Since there is no table by the name `trial_db`, let us go ahead and create a new table of the same name.

#### Create Table

To create a new table, use `dbWriteTable()`. It takes the following 3 arguments:

- connection name
- name of the new table
- data for the new table

Let us first create a new dataset `trial_db`. It has 2 columns, `x` and `y`, and 10 rows of data. Next, we create a new table of the same name in the database. In `dbWriteTable()`, we specify the following:

- `con`: database connection
- `"trial_db"`: name of the table in database
- `trial_data`: name of the dataset used to create the table in the database

Ensure that the name of the table in the database is always enclosed in single/double quotes.

```{r create_table} 
# sample data
x          <- 1:10
y          <- letters[1:10]
trial_data <- tibble::tibble(x, y)

# write table to database
DBI::dbWriteTable(con, "trial_db", trial_data)
```

Let us check if the table has been created.

```{r create_table_list}
DBI::dbListTables(con)
DBI::dbExistsTable(con, "trial_db")
```

#### Overwrite Table

Sometimes instead of creating a new table, you may want to overwrite the data in an existing table. In such cases, use the `overwrite` argument in `dbWriteTable()` and set it to `TRUE`. In the below example, we overwrite the `trial_db` table in the database using the data set `trial2_data`.

```{r overwrite_table}
# sample data
x      <- sample(100, 10)
y      <- letters[11:20]
trial2_data <- tibble::tibble(x, y)

# overwrite table trial
DBI::dbWriteTable(con, "trial_db", trial2_data, overwrite = TRUE)
```

Let us query sone data from `trial_db` table to ensure that it has been overwritten.

```{r view_data_overwrite}
DBI::dbGetQuery(con, "select * from trial_db")
```

#### Append Data

Alright! Now let us say instead of overwriting the data in the table, you want to append the data. In such cases, you can append data to an existing table by setting the `append` argument in `dbWriteTable()` to `TRUE`. In the below example, we append the data set `trial3_data` to the `trial_db` table in the database.

```{r append_data}
# sample data
x      <- sample(100, 10)
y      <- letters[5:14]
trial3_data <- tibble::tibble(x, y)

# append data
DBI::dbWriteTable(con, "trial_db", trial3_data, append = TRUE)
```

Let us check if the data has been appended successfully by querying data from the `trial_db` table.

```{r view_data_append_data}
DBI::dbGetQuery(con, "select * from trial_db")
```

#### Insert Rows

We can insert new rows into existing tables using:

- `dbExecute()`
- `dbSendStatement()`

Both the function take 2 arguments:

- connection name
- sql statement

In the below example, we insert a new row of data into the `trial-db` table in the database using `dbExecute().

```{r insert_wors_dbexecute}
DBI::dbExecute(con,
  "INSERT into trial_db (x, y) VALUES (32, 'c'), (45, 'k'), (61, 'h')"
)
```

Let us check if the new row of data has been inserted into the `trial_db` table by querying data from the same table.

```{r view_data_dbexecute}
DBI::dbGetQuery(con, "select * from trial_db")
```

In the next example, we insert another row of data into the `trial_db` table in the database using `dbSendStatement()`.

```{r insert_rows_dbsend}
DBI::dbSendStatement(con,
  "INSERT into trial_db (x, y) VALUES (25, 'm'), (54, 'l'), (16, 'y')"
)
```

Let us check if the new row of data has been inserted into the `trial_db` table by querying data from the same table.

```{r view_data_dbsend}
DBI::dbGetQuery(con, "select * from trial_db")
```

#### Remove Table

To delete/remove a table from the database, use `dbRemoveTable()`.

```{r remove_table}
DBI::dbRemoveTable(con, "trial_db")
```

### Your Turn

- check if `mytable` exists in the database
- create new table `mytable` using the first 3 rows of `mtcars` data set
- list all tables to check if the new table has been created
- overwrite `mytable` with the first 10 rows of `mtcars` data set
- append the 20th row of `mtcars` data set to `mytable`
- create a new table using the last 5 rows of `mtcars` and append it to `mytable`
- remove `mytable`

## Data Type

We know of the different data types in R such as integer, numeric/double, logical, factor etc. How do databases treat these data types? To know the data type of a particular value in a database, use `dbDataType()`. The first input is the database driver and the next is the value whose data type we are seeking. In the below example, we look at the data type of 3 different values in SQLite.

```{r data_types}
DBI::dbDataType(RSQLite::SQLite(), "a")
DBI::dbDataType(RSQLite::SQLite(), 1:5)
DBI::dbDataType(RSQLite::SQLite(), 1.5)
```

## Generate SQL Query

`sqlCreateTable()` will generate the SQL statement for simple `CREATE TABLE` operations. In the below example, it generates the SQL statement for creating table `new` with two fields `x` and `y`.

```{r generate_sql_query}
DBI::sqlCreateTable(con, "new", c(x = "integer", y = "text"))
```

`sqlAppendTable()` will generate the SQL statement for simple `INSERT` operations. In the below example, it generates the SQL statement for inserting a new row of data into the `trial_db` table. 

```{r generate_sql_append_query}
trial_new <- data.frame(x = 30, y = 'k')
DBI::sqlAppendTable(con, "trial_db", trial_new)
```

```{r dbi_disconnect, include=FALSE}
DBI::dbDisconnect(con)
```